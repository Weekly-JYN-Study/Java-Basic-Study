# 13.제네릭
- 제네릭 타입을 이용하여 "잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거"한다. 
- 메소드를 정의할 때 타입(type)을 파라미터(parameter)로 사용할 수 있게 한다.
 
## 13.1 이점
  - 1. 컴파일 시 강한 타입체크를 하여 에러 방지
  - 2. 형변환을 제거한다. 지네릭이 아닌 코드는 불필요한 타입 변환을 하기 때문에 성능에 악영향을 미친다. 
  
    ```java
    // 비제네릭 코드 
    List list = new ArrayList();
    list.add("hello");
    String str = (String)list.get(0);
    ```

    ```java
    //제네릭 코드
    List<String> list = new ArrayList<String>();
    list.add("hello");
    String str = list.get(0); //형변환 x
    ```

## 13.2 제네릭 타입(class<T>, interface<T>)
- 제네릭 타입 == 타입을 파라미터로 가지는 클래스와 인터페이스. 
- 클래스와 인터페이스 이름 뒤에 "<>" 가 붙고, 그 사이에 타입 파라미터를 넣는다.
  
  - 타입 파라미터?
    - 1. 일반적으로 대문자 알파벳 한 글자
    - 2. 제네릭 타입을 실제 코드에서 사용하려면 타입 파라미터에 구체적인 타입을 지정해야 한다.

- Object 타입을 쓰면 위의 List 예제와 같이, 형변환이 일어난다.
- **모든 종류의 객체를 저장하면서 형변환이 발생하지 않는 것 == 제네릭**
- 타입 파라미터를 사용해서 오브젝트 객체를 대체 -> 클래스로 객체를 생성할 때 구체적인 타입으로 변경된다.

- 클래스를 설계할 때 구체적인 타입을 명시하지 않고, 타입 파라미터로 대체했다가 실제 클래스가 사용될 때 구체적인 타입을 지정함으로써 타입변환을 최소화한다. 

## 13.3 멀티 타입 파라미터 (class<K,V,..>, interface<K,V>,.. )
- 두개 이상의 멀티 타입 파라미터를 사용할 수 있다. 이 경우 콤마(,)로 구분한다.
- 자바 컴파일러는 타입 파라미터 부분에 <> 연산자를 사용하면 타입 파라미터를 유추해서 자동으로 설정해준다. 

## 13.4 제네릭 메소드 (<T,R> R method(T t))
- 매개 타입과 리턴 타입으로 타입 파라미터를 갖는 메소드
- 리턴 타입 앞에 <> 기호를 추가하고 타입 파라미터를 기술한 다음, 리턴 타입과 매개타입으로 타입 파라미터를 사용하면 된다.
  
  ```java
    public <T> Box<T> boxing (T t) { ... }
  ```
  
  ```java
    public <타입파라미터..> 리턴타입 메소드명 (매개변수..) { ... }
  ```

- 제네릭 메소드는 두가지 방식으로 호출할 수 있다.
  
    1. 타입 파라미터를 명시적으로 Integer로 지정
    ```java
    Box<integer> box = <Integer>boxing(100); 
    ```

    2. 매개값을 보고 구체적 타입을 추정. 타입 파라미터를 Integer로 추정
    ```java
    Box<integer> box = boxing(100); 
    ```

## 13.5 제한된 타입 파라미터 (<T extends 최상위타입>)
- 타입파라미터에 지정되는 구체적인 타입을 제한할 필요가 가끔 있다.
- 예를 들어 숫자를 연산하는 제네릭 메소드는 매개값으로 Number혹은 하위 클래스 타입(Byte, Short, Integer..)의 인스턴스만 가져야한다.
- 이러한 경우에 제한된 타입 파라미터(bounded type parameter)가 필요

- 선언하려면, 타입 파라미터 뒤에 extends 키워드를 붙이고 상위 타입 명시 
  - 상위 타입 : 클래스뿐만 아니라 인터페이스도 가능
  - 인터페이스라해서 implements 쓰지 않는다

## 13.6 와일드카드 타입(<?>, <? extends ...>, <? super ...>)
- 코드에서 ? 를 일반적으로 와일드카드라고 부른다. 
- 구체적인 ㅏ입 대신 와일드카드를 세가지 형태로 사용할 수 있다.

    1. 제네릭 타입<?> 
       1. 제한 없음 
       2. 모든 클래스나 인터페이스 타입이 올 수 있다.
    2. 제네릭타입<? extends 상위타입> 
       1. 상위 클래스 제한
       2. 상위 타입이나 하위 타입만 올 수 있다.
    3. 제네릭 타입<? super 하위타입>
       1. 하위 클래스 제한
       2. 하위타입이나 상위 타입이 올 수 있다.

## 13.7 제네릭 타입의 상속과 구현
- 제네릭 타입도 부모 클래스가 될 수 있다.
    
    ```java
    public class ChildProduct<T,M> extends Product<T,M> { ... }
    ```
- 자식 제네릭 타입은 추가적으로 타입 파라미터를 가질 수 있다. 
- 제네릭 인터페이스를 구현한 클래스도 제네릭 타입이 된다.

    
  

# 14.람다식

## 14.1 람다식이란?
자바는 객체 지향 프로그래밍이 유행이던 시기에 디자인된 언어, 최근들어 함수적 프로그래밍이 부각되고 있다.
객체 지향 프로그래밍 + 함수형 프로그래밍을 혼합하여 더욱 효율적인 프로그래밍이 될 수 있도록 언어는 발전되는중.

**자바는 함수적 프로그램을 위해 람다식을 지원한다.**

1. 코드가 간결해진다
2. 컬렉션 요소를 필터링하거나 매핑해서 원하는 결과를 쉽게 집계할 수 있다.
3. 람다식의 형태는 매개 변수를 가진 코드 블록이지만, 런타임 시에는 익명 구현 객체를 생성한다.

> 람다식은 "(매개변수) -> {실행코드}" 형태로 작성된다.

-> 함수 정의 형태를 띄고 있지만 런타임 시에 인터페이스의 익명 구현 객체로 생성된다. 

## 14.2 람다식 기본 문법
> (타입 매개변수, ...) -> { 실행문; ...  }

- '->' 기호는 매개 변수를 이용해서 중괄호 '{}'를 실행한다는 뜻으로 해석하면 된다.
- 하나의 매개변수만 있다면 괄호()를 생략할 수 있고, 하나의 실행문만 있다면 중괄호 {}도 생략할 수 있다.
  > a -> {system.out.println(a);  } 
- 만약 매개변수가 없다면 빈 괄호를 반드시 사용 
  > () -> {system.out.println(a);  } 
- 중괄호 {}에 return 문만 있을 경우 return 문을 사용하지 않고 다음과 같이 작성하는 것이 정석
  > (x,y) -> x + y

## 14.3 타겟 타입과 함수적 인터페이스
- 자바는 메소드를 단독으로 선언할 수 없고 항상 클래스의 구성 멤버로 선언하기 때문에 람다는 이 메소드를 가지고 있는 객체를 생성해낸다.
- 인터페이스는 직접 객체화 할수 없기 때문에 구현 클래스가 필요
- 람다식은 익명 구현 클래스를 생성하고 객체화한다.
- 대입될 인터페이스의 종류에 따라 작성 방법이 달라지기 때문에 람다식이 대입될 인터페이스를 람다식의 타겟 타입(target type) 이라 한다.

### 함수적 인터페이스 (@FunctionalInterface)
- 모든 인터페이스를 람다식의 타겟 타입으로 사용할 수 없다. 람다식이 하나의 메소드를 정의하기 때문에 두개이상의 추상 메소드가 선언된 인터페이스는 람다식을 이용해서 구현 객체를 생성할 수 없다.
- 하나의 추상 메소드가 선언된 인터페이스만이 람다식의 타겟 타입이 될 수 있는데, 이러한 인터페이스를 함수적 인터페이스라고 한다. 
- 두 개 이상의 추상 메소드가 선언되지 않도록 컴파일러가 체킹해주는 기능 
    > @FunctionalInterface : 두개이상의 추상 메소드가 선언되면 컴파일 오류 발생시킴

### 매개변수와 리턴값이 없는 람다식
    ```java
    @FunctionalInterface
    public interface MyFunctionalInterfacfe {
        public void method();
    } 
    ```
- 매개변수도 없고 리턴값도 없다
- 이 인터페이스를 타겟타입으로 갖는 람다식은 다음과 같이 작성한다. 
- 람다식에서 매개변수가 없는 이유는 method()가 매개변수를 갖지 않기 때문이다.
  

    ```java 
    MyFunctionalInterface fi = () ->  { } 
    ```

### 매개 변수가 있는 람다식

    ```java
    @FunctionalInterface
    public interface MyFunctionalInterfacfe {
        public void method(int x);
    }
    ```
-  매개변수가 있고 리턴값이 없다.

    ```java 
    MyFunctionalInterface fi = (x) ->  { } 또는 x ->  { }
    ``` 
- fi.method(5)로 호출 가능
  
### 리턴값이 있는 람다식
    ```java
    @FunctionalInterface
    public interface MyFunctionalInterfacfe {
        public int method(int x, int y);
    } 
    ```
-  매개변수가 있고 리턴값도 있다.
  
    ```java 
    MyFunctionalInterface fi = (x,y) ->  {...; return 값; } 
    ``` 

## 14.4 클래스 멤버와 로컬 변수 사용
- 클래스의 멤버는 제약 사항 없이 사용 가능하지만, 로컬 변수는 제약 사항이 따른다.

### 클래스의 멤버 사용
- this 키워드 사용할 때 주의할 것 
- 람다식에서 this는 내부적으로 생성되는 익명 객체의 참조가 아니라, 람다식을 실행한 객체의 참조이다. 
  
### 로컬 변수 사용
- 람다식은 메소드 내부에서 주로 작성되기 때문에 로컬 익명 구현 객체를 생성시킨다.
- 바깥 클래스의 필드나 메소드는 제한 없이 사용할 수 있으나, 메소드의 매개 변수또는 로컬 변수를 사용하면 이 두 변수는 final 특징을 가져야 한다. (9강.5.3 익명객체의 로컬 변수 사용 참고)
- 매개 변수 또는 로컬 변수를 람다식에서 읽는 것은 허용하지만, 람다식 내부 or 외부에서 변경은 어렵다.


## 14.5 표준API의 함수적 인터페이스
- 한개의 추상 메소드를 가지는 인터페이스들은 모두 람다식을 이용해서 익명 구현 객체로 표현 가능
  ![함수적 인터페이스 종류와 특징](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F2418983555FE5A372A)

## 14.6 메소드 참조
- 메소드를 참조해서 매개 변수의 정보 및 리턴 타입을 알아내어, 람다식에서 불필요한 매개 변수를 제거하는 것이 목적.
