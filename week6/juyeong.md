# 13.제네릭
- 제네릭 타입을 이용하여 "잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거"한다. 
- 메소드를 정의할 때 타입(type)을 파라미터(parameter)로 사용할 수 있게 한다.
 
## 13.1 이점
  - 1. 컴파일 시 강한 타입체크를 하여 에러 방지
  - 2. 형변환을 제거한다. 지네릭이 아닌 코드는 불필요한 타입 변환을 하기 때문에 성능에 악영향을 미친다. 
  
    ```
    // 비제네릭 코드 
    List list = new ArrayList();
    list.add("hello");
    String str = (String)list.get(0);
    ```

    ```
    //제네릭 코드
    List<String> list = new ArrayList<String>();
    list.add("hello");
    String str = list.get(0); //형변환 x
    ```

## 13.2 제네릭 타입(class<T>, interface<T>)
- 제네릭 타입 == 타입을 파라미터로 가지는 클래스와 인터페이스. 
- 클래스와 인터페이스 이름 뒤에 "<>" 가 붙고, 그 사이에 타입 파라미터를 넣는다.
  
  - 타입 파라미터?
    - 1. 일반적으로 대문자 알파벳 한 글자
    - 2. 제네릭 타입을 실제 코드에서 사용하려면 타입 파라미터에 구체적인 타입을 지정해야 한다.

- Object 타입을 쓰면 위의 List 예제와 같이, 형변환이 일어난다.
- **모든 종류의 객체를 저장하면서 형변환이 발생하지 않는 것 == 제네릭**
- 타입 파라미터를 사용해서 오브젝트 객체를 대체 -> 클래스로 객체를 생성할 때 구체적인 타입으로 변경된다.

- 클래스를 설계할 때 구체적인 타입을 명시하지 않고, 타입 파라미터로 대체했다가 실제 클래스가 사용될 때 구체적인 타입을 지정함으로써 타입변환을 최소화한다. 

## 13.3 멀티 타입 파라미터 (class<K,V,..>, interface<K,V>,.. )
- 두개 이상의 멀티 타입 파라미터를 사용할 수 있다. 이 경우 콤마(,)로 구분한다.
- 자바 컴파일러는 타입 파라미터 부분에 <> 연산자를 사용하면 타입 파라미터를 유추해서 자동으로 설정해준다. 

## 13.4 제네릭 메소드 (<T,R> R method(T t))
- 매개 타입과 리턴 타입으로 타입 파라미터를 갖는 메소드
- 리턴 타입 앞에 <> 기호를 추가하고 타입 파라미터를 기술한 다음, 리턴 타입과 매개타입으로 타입 파라미터를 사용하면 된다.
  
  ```
    public <T> Box<T> boxing (T t) { ... }
  ```
  
  ```
    public <타입파라미터..> 리턴타입 메소드명 (매개변수..) { ... }
  ```

- 제네릭 메소드는 두가지 방식으로 호출할 수 있다.
  
    1. 타입 파라미터를 명시적으로 Integer로 지정
    ```
    Box<integer> box = <Integer>boxing(100); 
    ```

    2. 매개값을 보고 구체적 타입을 추정. 타입 파라미터를 Integer로 추정
    ```
    Box<integer> box = boxing(100); 
    ```

## 13.5 제한된 타입 파라미터 (<T extends 최상위타입>)
- 타입파라미터에 지정되는 구체적인 타입을 제한할 필요가 가끔 있다.
- 예를 들어 숫자를 연산하는 제네릭 메소드는 매개값으로 Number혹은 하위 클래스 타입(Byte, Short, Integer..)의 인스턴스만 가져야한다.
- 이러한 경우에 제한된 타입 파라미터(bounded type parameter)가 필요

- 선언하려면, 타입 파라미터 뒤에 extends 키워드를 붙이고 상위 타입 명시 
  - 상위 타입 : 클래스뿐만 아니라 인터페이스도 가능
  - 인터페이스라해서 implements 쓰지 않는다

## 13.6 와일드카드 타입(<?>, <? extends ...>, <? super ...>)
- 코드에서 ? 를 일반적으로 와일드카드라고 부른다. 
- 구체적인 ㅏ입 대신 와일드카드를 세가지 형태로 사용할 수 있다.

    1. 제네릭 타입<?> 
       1. 제한 없음 
       2. 모든 클래스나 인터페이스 타입이 올 수 있다.
    2. 제네릭타입<? extends 상위타입> 
       1. 상위 클래스 제한
       2. 상위 타입이나 하위 타입만 올 수 있다.
    3. 제네릭 타입<? super 하위타입>
       1. 하위 클래스 제한
       2. 하위타입이나 상위 타입이 올 수 있다.

## 13.7 제네릭 타입의 상속과 구현
- 제네릭 타입도 부모 클래스가 될 수 있다.
    
    ```
    public class ChildProduct<T,M> extends Product<T,M> { ... }
    ```
- 자식 제네릭 타입은 추가적으로 타입 파라미터를 가질 수 있다. 
- 제네릭 인터페이스를 구현한 클래스도 제네릭 타입이 된다.

    
  







# 14.람다식

## 14.1 람다식이란?
## 14.2 람다식 기본 문법
## 14.3 타겟 타입과 함수적 인터페이스
## 14.4 클래스 멤버와 로컬 변수 사용
## 14.5 표준API의 함수적 인터페이스
## 14.6 메소드 참조
