# 6. 클래스

---

### **주요 키워드 및 개념 정리**

---

###### 객체 간의 관계

- 집합 관계: 객체는 하나의 부품, 하나는 완성품
- 사용 관계: 객체 간의 상호작용
- 상속 관계: 상위 객체는 종류, 하위 객체는 구체적인 사물

###### 객체 지향 프로그래밍(Obejct Oriented Programming)

1. 완성품인 객체를 모델링
2. 집합 관계에 있는 부품 객체와 사용 관계에 있는 객체를 하나씩 설계
3. 조립

###### 캡슐화(Encapsulation)

필드와 메소드를 캡슐화해서 외부로 부터 보호하고 실제 구현 내용을 감추는 것. 외부 객체는 객체 내부의 구조를 알지 못하며 노출해서 제공하는 필드와 메소드만 이용.

###### 상속(Inheritance)

상위 객체를 재사용해서 하위 객체를 쉽고 빠르게 설계할 수 있도록 도와주고 반복된 코드의 중복을 줄여준다. 상위 개체의 수정으로 하위 객체들도 수정되게 해 유지 보수 시간을 줄여준다.

###### 다형성(Polymorphism)

하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할수 있도록 해준다. 자바는 다형성을 위해 부모 클래스 또는 인터페이스의 타입 변환을 허용한다. (자식객체, 구현객체 대입) 객체의 부품화가 가능.

###### 생성자 사용 이유

객체 생성 시 초기화를 담당한다. 필드를 초기화하거나, 메소드를 호출해 객체를 사용할 준비를 한다. 생성자를 실행시키지 않고는 클래스로부터 객체를 만들 수 없다.

###### 정적 멤버와 메소드 영역

클래스 로더가 클래스를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 정적 필드와 정적 메소드를 관리한다.

###### 싱글톤 객체

1. 생성자에 private 접근 제한자 붙이기
2. 자신의 타입인 private 정적 필드를 선언하고, 자신의 객체를 생성해 초기화
3. 외부에서 호출할 수 있는 정적 메소드인 getInstance() 선언하고 자신의 객체를 리턴

###### 접근 제한자(Acces Modifier)를 사용하는 이유

- 객체 생성을 막기 위해 생성자를 호출하지 못하게 하기 위해
- 객체의 특정 데이터를 보호하기 위해 해당 필드에 접근하지 못하도록 하기 위해
- 특정 메소드를 호출할 수 없도록 제한 하기 위해

###### Getter와 Setter

객체 지향 프로그래밍에서는 객체의 무결성을 지키기 위해 메소드를 통해 데이터를 변경하는 방법을 사용 한다. 데이터는 외부에서 접근할 수 없도록 하고, 메소드는 공개해서 메소드로 데이터에 접근하도록 한다.

- 매개값을 검증해 유효한 값만 데이터로 저장하는 역할을 하는 메소드가 setter
- 메소드로 필드값을 가공(변경)한 후 외부로 전달하는 메소드가 getter
- 필드값을 안전하게 변경 및 사용

### **관심 가는 내용**

---

###### new 연산자

힙 영역에 객체를 생성시킨 후, **객체의 주소를 리턴**한다. 그래서 이 주소를 이용해 참조 타입인 클래스 변수에 저장해 두면, 변수를 통해 객체를 사용 가능.

- 리턴된 객체의 주소를 변수에 저장 -> 변수가 객체를 참조

###### 인스턴스 멤버와 메소드 영역

같은 클래스에서 생성된 인스턴스 객체는 객체마다 따로 존재 하고, 인스턴스 메소드는 메소드 영역에 저장되고 **공유**된다.
