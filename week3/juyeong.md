# 9.중첩 클래스와 중첩 인터페이스
내용이 어렵다! 일단 직접 사용해본 경험이 적어서 더 그런 것 같다.
중첩 인터페이스가 사용되는 실제 예시가 UI 프로그래밍이나 스레드 사용인데, 해당 개발을 할 경험이 있을 때 다시 봐야겠다.
지금은 완벽히 이해하기 보다 이러한 개념이 있구나 정도로 이해하고 넘어갔던 챕터.

재밌던 부분은 
컴파일러가 final한 클래스임을 인지하고 있다는 것..?


## 중첩클래스
중첩 클래스는 클래스 내부에 선언하는 클래스인데, 위치에 따라 
멤버클래스/로컬클래스 등으로 나뉘고 해당 클래스 내에 사용할 수 있는 
인스턴스/ 정적 타입의 객체또한 다르며, 접근제한도 이루어진다.

## 중첩클래스를 사용하는 이유
클래스 내부에 선언하기 때문에 두 클래스의 멤버들을 서로 쉽게 접근할 수 있다는 장점과, 외부에는 불필요한 관계 클래스를 
감춤으로써 코드의 복잡성을 줄일 수 있다.

## 중첩 인터페이스
해당클래스와 긴밀한 관계를 맺는 구현 클래스를 만들기 위해 사용한다. 클래스 내부에 선언된 인터페이스이다.
주로 UI프로그래밍에서 이벤트를 처리할 목적으로 활용된다. 

UI 내부에 삽입되는 인터페이스 혹은 클래스는 주로 VIew 클래스 내부에 자리잡아서,
View와만 관계를 맺게 된다.

## 중첩클래스의 종류
- 멤버클래스, 정적 멤버 클래스, 로컬 클래스(메소드 내부)
- 로컬클래스는 보통 비동기 처리를 위해 스레드 객체를 만들 때 사용

### 중첩클래스는 컴파일 시 $ 바이트 코드가 추가된다.
- 멤버클래스 : 바깥클래스명$멤버클래스명.class
- 로컬클래스 : 바깥클래스명$1멤버클래스명.class

## 중첩클래스의 접근제한
기본적으로 중첩클래스는 정적클래스 혹은 인스턴스로 생성되어 접근 제한이 걸린다. 
- 바깥 필드와 메소드에서 사용 제한
- 멤버 클래스에서 사용 제한
- 로컬 클래스에서 사용 제한

## 중첩 인터페이스
- 클래스 멤버로 선언된 인터페이스
- 클래스 내부에 선언하는 이유는 해당 클래스와 관계를 맺기 때문
- UI처리 시에 많이 이용한다
-> 결국 인터페이스는 다형성 극대화를 위한 것

## 익명객체
- 이름이 없는 객체로, 단독 생성은 불가능하고 클래스를 상속하거나 인터페이스를 구현해야만 생성할 수 있따.
- 필드의 초기값, 로컬 변수의 초기값, 매개변수의 매개값으로 주로 활용
- UI 이벤트 처리, 스레드 객체 생성 등에 활용

🔥스레드 객체 생성(뒤에 스레드 파트있음)시 중첩 인터페이스 다시 보러오기

### 익명 자식 객체 생성
- 자식클래스가 재사용될 일이 없고 해당 필드와 변수의 초기값으로 사용하는 경우라면 익명자식객체를 생성해서 초기값으로 대입하는 것이 좋은 방법이다.


# 10.예외
예외는 사용자의 잘못된 조작 혹은 개발자의 잘못된 코딩으로 인해 발생하는 프로그램 오류.
예외의 종류는 
1. 일반 예외 (Exception)
2. 실행 예외 (runtime Exception)
3. 사용자 정의 예제 (개발자가 정의함)

이렇게 3개로 나누어 작성할 수 있다.

- 일반예외와 실행예외는 어떤 클래스를 상속받고 있는지에 따라 구분된다. 일반예외는 "java.lang.Exception", 실행예외는 "java.lang.runtimeException"을 상속한다. 

## 실행예외

- 자바 컴파일러가 체크를 하지 않음. 오로지 개발자의 경험에 의해 예외 처리 코드를 삽입해야 한다. 자바 프로그램에서 자주 실행되는 예외 몇가지가 있는데 미리 알아두면 좋다.
1) NullPointerException
   1) null값을 갖는 참조변수에 . 도트 연산자를 사용하여 객체에 접근하면 발생함
   2) 참조할 메모리 주소가 없는데 객체를 사용하려 해서 예외 발생 
2) ArrayIndexOutOfBoundsException
   1) 배열에서 인덱스 범위를 초과하여 사용할 경우 발생
   2) 해결방법을 책에서 제시했는데 첨보는 방법이라 신기했음.. 
3) NumberFormatException
   1) 잘못된 문자(eg. '100a')를 숫자로 파싱하려 할 때 발생한다.
4) ClassCastException
   1) 타입변환(Casting)은 상위클래스와 하위클래스 간에 발생하고 구현클래스와 인터페이스간에도 발생한다. 이러한 관계가 아니라면 다른 클래스로 타입 변환할 수 없는데, 억지로 타입변환할 경우 ClassCastException가 발생한다.
   2) "instanceof x"로 타입간에 변환이 가능한지 제어문의 조건으로 확인하면 예방할 수 있다. 

## 예외 처리 코드
### try- catch - finally
![작성방법](https://velog.velcdn.com/images/dev-taewon-kim/post/fe28db90-4c01-463a-8c97-91637634b2b6/image.png)

try: 예외 발생할 수 있는 코드
catch: 예외 발생하면 실행할 코드
finally: 예외 발생 상관없이 언제나 실행됨

* 이 때, try,catch 블록에서 return문을 사용하더라도 finally블록은 항상 실행된다.

## catch 문에 대하여
### 다중 catch
- catch 블록이 여러개여도 단 하나의 블록만 실행된다. try 블록에서 동시다발적으로 예외가 발생하지 않고, 하나의 예외가 발생하면 즉시 실행을 멈추고 해당 catch블록으로 이동하기 때문이다.
### catch 순서
작성 시, 상위 예외 클래스가 하위 예외 클래스보다 아래쪽에 위치해야한다. 예외가 발생하면 위에서부터 차례대로 검색되는데, 이 때 상위클래스가 위에 있으면 아래의 하위클래스는 실행되지 않기 때문이다. 
### multi catch
 ```
 try {

} catch (ArrayIndexOutOfBoundsException | NumberFormatException e) {

}
 ```

## 자동 리소스 닫기
리소스 : 데이터를 읽고 쓰는 객체.
close();로 굳이 닫아줄 필요가 없다. try블록이 정상적으로 실행을 완료했거나 도중에 예외가 발생하게 되면 자동으로 close()메소드가 호출된다. 

## 예외 떠넘기기 (throws)
1) throws뒤에 예외의 종류를 나열하는 것이 일반적이지만 throws Exception으로 모든 예외 던지기 가능하다.
2) main 메소드에서 throws로 예외를 던져버리면, 사용자 입장에서는 갑자기 알 수 없는 메세지가 뜨며 프로그램이 종료되기 때문에 주의해야 한다.
3) 예외 던지기는 패턴이 있어서, 이 패턴을 코드를 통해 이해하고 체화하는 것이 베스트라 생각했다.


## 사용자 정의 예외
- 일반 예외로 선언할 경우 Exception을 상속하면 되고, 실행 예외로 선언할 경우에는 RuntimeException을 상속
```
public class XXXException extends [ Exception | RuntimeException ] {
	public XXXException() {} //기본생성자
	public XXXException(String message) { super(message); } //에러메시지 출력을 위해 매개변수로 String을 받음
}
 ```

 - 예외 발생 코드를 가지고 있는 메소드는 대부분 자신을 호출한 곳에서 예외를 처리하도록 throws 키워드로 예외를 떠넘김
```
public void method() throws XXXException {
		throw new XXXException("메시지");
	}
 ```
  


## 예외 정보 얻기
- try 블록에서 예외가 발생되면 예외 객체는 catch 블록의 매개변수에서 참조하게 되므로 매개 변수를 이용하면 예외 객체의 정보를 할 수 있다.

가장 많이 사용되는 메소드는 getMessage()와 printStackTrace()이다.

예외가 발생한 상세한 원인을 세분화하기 위해 예외 코드를 포함하기도 하는데, 예를 들어 데이터베이스에서 발생한 오류들은 예외 코드가 예외 메시지로 전달된다. 이와 같은 예외 메시지는 다음과 같이 catch 블록에서 getMessage() 메소드의 리턴값으로 얻을 수 있다.
 ```
try {
		
		} catch(예외클래스 e) {
			// 예외가 가지고 있는 Message 얻기
			String message = e.getMessage();
			
			// 예외의 발생 경로를 추적
			e.printStackTrace();
		}
 ```








