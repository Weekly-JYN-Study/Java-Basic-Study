# 12. 멀티 스레드

## 주요 키워드 및 개념 정리

#### 멀티 스레드

하나의 프로세스가 두 가지 이상의 작업을 처리할 수 있게 한다. (멀티 태스킹)  
멀티 스레드는 하나의 프로세스 내부에 생성되어 스레드간 서로 영향을 준다.

- 사용
  - 대용량 데이터의 데이터 분할해 병렬 처리
  - UI 애플리케이션에서 네트워크 통신
  - 다수 클라이언트 요청 처리 서버 개발

#### 메인 스레드

자바 애플리케이션은 메인 스레드가 main() 메소드를 실행하면서 시작된다. 필요에 따라 메인 스레드가 작업 스레드들을 만들어 병렬로 코드를 실행한다.

#### 작업 스레드 생성

- Thread 클래스로 생성

  ```java
  Thread thread = new Thread(Runnable target);
  ```

  Runnable 구현 클래스에서 run()을 재정의해 작업 스레드가 실행할 내용을 작성한다.
  `thread.start`로 작업 스레드 실행(Runnable의 run()실행).

- Thread 하위 클래스로 생성
  ```java
  public class WorkerThread extends Thread {
    @Override
    public void run() {
    ///스레드가 실행할 코드
    }
  }
  ```
  작업 스레드의 작업 내용을 Thread의 하위 클래스에서 run()를 재정의 하면서 포함한다.

#### 멀티 스레드의 동시성, 병렬성

멀티 스레드는 **동시성(Concurrecy)** 또는 **병렬성(Parallelism)** 으로 실행된다.

동시성은 멀티 작업을 싱글 코어에서 멀티 스레드가 번갈아가며 실행하는 성질.

병렬성은 멀티 작업을 멀티 코어에서 개별 스레드를 동시에 실행하는 성질.

#### 스레드 스케줄링

스레드의 개수가 코어 수보다 많을 경우 어떤 순서에 의해 동시성으로 실행할것인가 결정하는 것.

- 우선순위(Priority)방식: 우선 순위가 높은 스레드가 실행 상태를 더 많이 가짐.(우선순위 부여 가능)
- 순환 할당(Round-Robin) 방식: 스레드에 시간 할당량(Time Slice)를 정해 정해진 시간만큼 실행.

#### 멀티스레드 환경에서 공유 객체 사용

멀티 스레드 프로그램에서 스레드들이 객체를 공유해서 작업하는 경우 객체의 상태가 다른 스레드에 의해 변경될 수 있어 문제가 발생한다.

#### 임계 영역(critical section)

멀티 스레드 프로그램에서 단 하나의 스레드만 실행할 수 있는 코드 영역. (스레드가 끝날 때 까지 다른 스레드가 변경할 수 없음)
스레드가 객체 내부의 임계 영역에 들어가면 즉시 객체에 **잠금**을 걸어 다른 스레드가 실행하지 못하도록 한다.  
-> 동기화 메소드, 동기화 블록 사용

#### 동기화 메소드

메소드 선언에 `synchronized` 키워드. 인스턴스 메소드, 정적 메소드에 붙을 수 있다.

#### 동기화 블록

메소드 전체 내용이 아닌 일부 내용만 임계 영역으로 만들때 사용한다.

#### 스레드 상태

- 객체 생성
  - NEW: 스레드 객체가 생성되어 start() 호출 안 된 상태.
- 실행 대기
  - RUNNABLE: 실행 상태로 갈 수 있는 상태. 스케줄링된 상태.
- 일시 정지
  - WATING
  - TIMED_WATING
  - BLOCKED
- 종료
  - TERMINATED: 실행을 마친 상태

#### 스레드 상태 제어

실행 중인 스레드의 상태를 변경하는 것. 안정적인 프로그램 실행을 위해 멀티 스레드 프로그램에서 상태 제어가 중요하다.

- **interupt()**:
  일시 정지의 스레드에서 InterruptedException예외 발생 시킴
- **notify(), notifyAll()**:
  동기화 블록 내 wait() 호출해 일시 정지 상태인 스레드를 실행 대기 상태로.
- **sleep()**:
  주어진 시간 동안 스레드 일시 정지 상태로.
- **join()**:
  호출한 스레드를 일시 정지 상태로. 다른 스레드의 종료 기다리기.
- **wait()**:
  동기화 블록 내 스레드를 일시 정지 상태로.(매개값으로 시간이 주어지지 않으면 notify(), notifyAll())
- **yield()**:
  우선순위가 동일한 다른 스레드에 실행 양보하고 실행 대기 상태로

#### 스레드 안전하게 종료

- stop 플래그 이용  
  stop 플래그 필드를 만들어 값이 false가 되면 while문을 빠져나와 run()을 종료 하도록 유도.  
  `private boolean stop`

- interrupt() 이용  
  스레드가 일시 정지 상태에 있을때 InterruptedException 예외를 발생시켜 run()을 정상 종료.

#### 데몬 스레드 daemon thread

주 스레드의 작업을 돕는 보조적인 역할을 하는 스레드이다. 주 스레드가 종료되면 데몬 스레드는 강제적으로 자동 종료된다.  
주 스레드가 데몬이 될 스레드의 setDaemon(true)를 호출해 데몬 스레드로 만든다.

> 자동 저장, 미디어 플레이어 동영상 및 음악 재생, 가비지 컬렉터

#### 스레드 그룹

관련된 스레드를 묶어서 관리할 목적으로 이용한다.

> JVM 실행 - system 스레드 그룹 생성 - JVM 운영 스레드들 생성 - main 스레드 그룹 생성(system 그룹 하위) - main 스레드 포함

#### 스레드 그룹의 interrupt()

스레드 그룹에 포함된 모든 스레드들을 일괄 interrupt한다. 포함된 모든 스레드의 interrupt()를 내부적으로 호출해준다. InterruptedException 예외 처리는 개별 스레드에서 해야 한다.

#### 스레드풀

병렬 작업 처리가 많아지면 스레드 개수가 증가되고, 스레드 생성과 스케줄링으로 메모리 사용량이 늘어나 애플리케이션의 성능이 저하된다.

갑작스런 병렬 작업 폭증으로 인한 스레드 폭증을 막기 위해 작업큐와 스레드풀을 사용한다.

java.util.concurrent 패키지 Excecutor 클래스의 정적 메소드를 이용해 ExcecutorService 구현 객체를 만들어 스레드풀을 생성한다.

#### 스레드풀 생성

- `newCached(ThreadPool())`
  - 추가된 스레드가 60초 동안 아무 작업 X -> 추가된 스레드 종료 및 풀에서 제거
- `newFixedThreadPool(int nThreads)`
  - 코어 스레드 수: nThreads
  - 최대 스레드 수: nThreads
  - 스레드가 작업 처리 안하고 있어도 삭제X -> 스레드 재사용

#### 스레드풀 종료

스레드풀 스레드는 main 스레드가 종료되더라도 작업 처리를 위해 계속 실행 상태로 있다. 애플리케이션을 종료 하려면 스레드풀을 종료해 스레드들이 종료 상태가 되도록 해야 한다.

- `ExcecutorService` 종료 메소드
  - `shutdown()`: 현재 작업 + 작업 큐 대기 모든 작업 처리한 뒤 스레드풀 종료
  - `shotdownNow()`: 현재 작업 interrupt로 작업 중지해 스레드풀 종료, 작업 큐의 미처리된 작업 리턴(`List<Runnable>`)
  - `awaitTermination(long timeout, TimeUnit unit)`: 모든 작업 처리를 timeout 시간 내 완료 O -> true, 시간 내 완료 X -> 작업 처리 중 스레드 interrupt + false 리턴

#### 스레드풀 - 작업 생성

하나의 작업은 Runnable 또는 Callable의 구현 클래스이다.

스레드풀의 스레드는 작업 큐에서 Runnable 또는 Callable 객체를 가져와 run()(리턴값X) 또는 call()(리턴값O) 메소드를 실행한다.

#### 스레드풀 - 작업 처리 요청

작업 처리 요청이란 ExcecutorService의 작업 큐에 작업 객체(Runnable 또는 Callable)를 넣는 행위를 말한다.

- `ExcecutorService`의 작업 처리 요청 메소드
  - `execute(Runnable command)`
    - 리턴 값X
    - 작업 처리 도중 예외 발생 시 스레드 종료 + 스레드 스레드풀에서 제거
  - `submit(Runnable task)`
  - `submit(Runnable task, V result)`
  - `submit(Callable<v> task)`
    - 작업 처리 결과를 얻을 수 있는 Future 객체 리턴.
    - 작업 처리 도중 예외 발생 해도 스레드 재사용 -> 스레드 생성 오버헤더 줄임

#### 블로킹 방식의 작업 완료 통보

작업 처리 요청 메소드 submit()의 리턴 객체인 **Future 객체**는 작업이 완료될 때까지 기다렸다가(지연 = 블로킹) 최종 결과를 얻는데 사용된다.

Future를 지연 완료(pending completion)객체라고 한다.

Future의 get() 메소드를 호출하면 블로킹되었다가 작업을 완료하면 처리 결과를 리턴한다.  
-> 블로킹을 사용하는 작업 완료 통보 방식

스레드가 작업 완료 전까지 get()이 블로킹되어 다른 코드를 실행할 수 없기 때문에 **get() 호출은 새로운 스레드 이거나 스레드풀의 또 다른 스레드**가 되어야 한다.

#### 리턴값이 없는 작업 완료 통보

리턴값이 없는 작업은 Runnable 객체로 생성하고, 결과값이 없는 작업 처리 요청은 `submit(Runnable task)` 메소드를 사용한다. 이 때 리턴되는 Future 객체는 정상완료시 null을 리턴 한다.(그 외 에외 발생)

#### 리턴값이 있는 작업 완료 통보

작업 완료 후 처리 결과가 필요하면 Callable 객체로 작업을 생성하고, submit()으로 작업 처리 요청을 한다.

#### 작업 처리 결과를 외부 객체에 저장

공유 객체인 Reuslt 객체를 사용해 두 개 이상의 스레드 작업을 취합할 목적으로 사용한다.

작업 처리 요청은 `submit(Runnable task, V result)`을 사용한다. 호출하면 즉시 `Future<V>` 객체가 리턴되고 get() 메소드를 호출하면 블로킹 되었다가 작업 완료시 V 타입 객체를 리턴한다.

작업 객체는 Runnable 구현 클래스로 생성하고, 작업 결과를 저장할 **Result 객체를 생성자를 통해 주입**한다.

#### 작업 완료 순으로 통보

스레드풀에서 작업 처리가 완료된 것만 통보 받으려면 CompletionService의 poll()과 take() 메소드를 사용한다.

작업 처리 요청은 submit()메소드를 이용한다.

#### 콜백 방식의 작업 완료 통보

애플리케이션이 스레드에 작업 처리 요청 후, 작업을 완료하면 특정 메소드를 자동 실행하는 콜백(callback) 방식을 이용해 작업 완료 통보 받는 방식이다.

작업 처리 요청 후 다른 기능을 수행할 수 있다.

Runnable 구현 클래스를 작성하면서 콜백 기능을 구현하면 된다. (콜백 메소드 직접 구현 또는 CompletionHandler 이용)

## 관심 가는 내용

#### 스레드 상태 제어 메소드 wait(), notify(), notifyAll()

Thread 클래스가 아닌 Object 클래스의 메소드이다. 그래서 모든 공유 객체(의 동기화 메소드 또는 동기화 블록)에서 호출 가능하다.

#### ThreadGroup 주요 메소드들

- checkAccess(): 현재 스레드가 스레드 그룹 변경 권한 있는지 체크. 없으면 SecurityException 발생.
- destroy(): 그룹 내 모든 스레드가 종료 상태일 때, 현재 그룹 및 하위 그룹 모두 삭제
- isDestroyed()
- getMaxPriority(): 스레드가 가질 수 있는 최대 우선순위
- setMaxPriority(int pri): 현재 그룹 스레드의 최대 우선순위 설정
- getName()
- getParent(): 현재 그룹의 부모 그룹을 리턴.
- parentOf(ThreadGroup g): 현재 그룹이 매개값인 스레드 그룹의 부모인지 여부
- isDaemon()
- setDaemon(boolean daemon): 현재 그룹을 데몬 그룹으로 설정
- list(): 현재 그룹에 포함된 스레드와 하위 그룹에 대한 정보 출력
- interrupt()

#### CompletionService의 메소드

- poll(): 완료된 작업의 Future를 가져온다. 없다면 즉시 null 리턴.
- take(): 완료된 작업의 Future를 가져온다. 없다면 있을 때까지 블로킹.
